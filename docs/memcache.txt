Memcache
========

Memcache is an in-memory transient key/value store typically used for caching.  It's a key technology for building scalable web apps.

If you are already using memcache, you won't need to rewrite your code for it to run on Heroku. Only the gem dependency declaration and the memcache client object initialization ([described below](http://0.0.0.0:4567/memcache#rails-setup)) needs to change.   

Gem Installation
----------------

First remove any memcache client gems you may already be using from your application, such as memcache-client.

You must use a memcache gem that supports SASL. There are two available:

1. <b>Dalli (recommended)</b>: We recommend using [dalli](http://github.com/mperham/dalli). Dalli supports Rails 2 & 3 and Ruby 1.8.7 & 1.9.2. It is compatible with all of our [deployment stacks](/stack), and is the only gem you can use if you wish to use memcache for your sessions store in rails 2 or 3. Full setup instructions for using dalli are available at the [Dalli readme](http://github.com/mperham/dalli). Please note that Dalli does not support older caching libraries such as cache-money or cache_fu.    

2. <b>memcached-northscale</b> is a ruby interface to the libmemcached C client. [Memcached-northscale](http://rubygems.org/gems/memcached-northscale) should be used only if you require compatibility with old caching libraries like cache-money. 

Add whichever Gem you choose to your [Gemfile](/bundler) and run `bundle install`.

NOTE: <b>Mac OS 10.5 Users</b> A bug in port / Mac OS 10.5 causes an error when trying to build the memcached-northscale gem. Snow Leopard (10.6) users are unaffected. To resolve this, uninstall the cyrus-sasl2 library, and then build the memcached-northscale gem. Once the memcached-northscale gem is built, you can reinstall the cyrus-sasl2 package if you require it.<pre style="margin-right:15px">$ sudo port -f uninstall cyrus-sasl2</pre>

Local Setup
-----------

You will need to run a local memcached process to test against with Sinatra or other Ruby app.  Install it on Mac OS X:

    :::term
    $ sudo port install memcached

Or on Ubuntu:

    :::term
    $ sudo apt-get install memcached

Or [follow these instructions](http://www.codeforest.net/how-to-install-memcached-on-windows-machine) for Windows.

You can also download the source from [the memcached site](http://memcached.org/).

Now run the memcached daemon:

    :::term
    $ memcached -vv
    slab class   1: chunk size     88 perslab 11915
    ...
    <15 server listening

Deploying to Heroku
-------------------

To use memcache on Heroku, install the memcache add-on:

    :::term
    $ heroku addons:add memcache

If you're using the memcached gem as described above, your app will use memcache on Heroku without any further code changes.


Rails Setup
-----------

Rails 2.3.3 and later abstracts the caching mechanisms through `Rails.cache`. You must be using Rails 2.3.3 or newer to use memcache on Heroku.

For Rails version 2.3.3 and higher using .gems, update your config/environment.rb:

    :::ruby
    config.gem 'memcached-northscale', :lib => 'memcached'
    require 'memcached'
    
Configure your app to use memcache for the cache store in production.  Add the following to config/environment/production.rb:

    :::ruby
    config.cache_store = :mem_cache_store, Memcached::Rails.new
    
In your development environment, Rails.cache will default to an in-memory memory store that doesn't require a running memcached.

You can test writing to the local memory cache in a console:

    :::term
    $ script/console
    >> Rails.cache.write('color', 'red')

And fetching the data back:

    >> Rails.cache.read('color')
    => "red"
    
Rails Caching Strategies
------------------------

Heroku recommends against using 'automagic' caching libraries such as cache-money or cache_fu. We have spent time searching for an easy caching solution, but have found that it doesn't exist. In general caching is an application-specific endeavor. The below is a roadmap for approaching performance enhancement through caching on a Rails app running on Heroku.

Once you have [configured your application to use memcached], rails will automatically use it for both [action](/) and [fragment](/) caching.

#### Fix really slow requests first

Web applications will typically have a small handful of pages that take an exceptionally long time to load. On Heroku, long running requests can tie up your dynos and seriously effect application performance. Use [New Relic Silver or Gold](/newrelic) to determine which pages and database requests are running slowly (see the Web Transactions and Database tabs). Examine the longest running requests. If they are caused by slow database or API transactions, then use low-level caching (i.e. Rails.cache.read/write/fetch) to cache the information. 

#### Use Varnish to cache pages with no authentication or customization

Rails [built-in page-caching](http://guides.rubyonrails.org/caching_with_rails.html#page-caching) requires write-access to the file system. As such it does not work on Heroku. However our [Varnish HTTP Cache](/http_cache) will accomplish the same thing (and do it exceptionally quickly). HTTP caching support is built into every Heroku application and does not require memcached.

Varnish page caching is appropriate for pages that don't require any before_filter logic (typically authentication) and that are the same for all users (i.e. don't have any customized content). As the application owner, you simply need to decide how up-to-date (or out-of-date) you need the page to be. See the [http cache](/http-caching#caching-dynamic-content-by-age) documentation for instructions on how to set it up.

#### Use Action caching to cache pages with authentication or dynamic layouts

If your pages requires authentication or other before/after filters, the content can still be cached using rails [built-in action caching](http://guides.rubyonrails.org/caching_with_rails.html#action-caching). Fragment caching uses (and requires) the Heroku Memcache add-on. 

Simply add `caches_action :<action_name>` to your controller to turn on caching for specific actions. If your layout contains dynamic elements (such as your user's name or email address in the header), you can render the layout dynamically while still caching the action's contents. Use the `:layout => false` flag to accomplish this. Finally, you can use the `expire_action` command to remove the action from you cache when new data is written.

The following Rails controller code illustrate these concepts:

    :::ruby
    # products_controller.rb
    class ProductsController < ActionController

      before_filter :authenticate
      caches_action :index
      caches_action :show, :layout => false
      
      def index
        @products = Product.all
      end
      
      def show
        @product = Product.find(params[:id])
      end

      def create
        expire_action :action => :index
      end

    end

(source: [Rails Guides](http://guides.rubyonrails.org/caching_with_rails.html#action-caching))

#### Use fragment caching for partials or widgets.

Fragment caching is a great mechanism for caching widgets or partials in your application. Fragment caching uses (and requires) the Heroku Memcache add-on. For example, if your app lists products like this:

    :::ruby
    # index.html.erb
    <%= render :partial => "product", :collection => @products %>
    
    # _product.html.erb
    <div><%= link_to product, product.name %>: <%= product.price%></div>
    
Then could easily cache the partial for each individual product with fragment caching. Rails will automatically generate a cache key if you pass it an ActiveRecord object:

    :::ruby
    # _product.html.erb
    <% cache(product) do %> 
       <div><%= link_to product, product.name %>: <%= product.price%></div>
       <div><%= do_something(comlicated)%></div>
    <% end %>

Another fragment caching strategy is to cache widgets or other discrete portions of pages that do not need to be refreshed from your live datastore for each new page load. If for example the front page of your website listed top selling products, you could cache this fragment. Let's assume that you want to refresh the information every hour:

    :::ruby
    # index.html.erb
    <% cache("top_products", :expires_in => 1.hour) do %>
      <div id="topSellingProducts">
        <% @recent_product = Product.order("units_sold DESC").limit(20) %>
        <%= render :partial => "product", :collection => @recent_products %>
      </div>
    <% end %>

#### Use low-level caching to avoid costly database and API queries

Low-level caching entails using the Rails.cache object directly to cache any information. Use it to store any data that is costly to retrieve and that can afford to be somewhat out-of-date. Database queries or API calls are common uses for this. 

The most efficient way to implement low-level caching is using the `Rails.cache.fetch` method. It will read a value from the cache if it available; otherwise it will execute a block passed to it and return the result:

    >> Rails.cache.fetch('answer')
    ==> "nil"
    >> Rails.cache.fetch('answer') {1 + 1}
    ==> 2
    Rails.cache.fetch('answer')
    ==> 2

Consider the following example. An application with has a Product model with a class method returning all out of stock items, and an instance method that looks up the product's price on a competing website. The data returned by these methods would be perfect for low-level caching:

    :::ruby
    # product.rb
    
    def Product.out_of_stock
      Rails.cache.fetch("out_of_stock_products", :expires_in => 5.minutes) do
        Product.all.joins(:inventory).conditions.where("inventory.quantity = 0")
      end
    end
    
    def competing_price
      Rails.cache.fetch("/product/#{id}-#{updated_at}/comp_price", :expires_in => 12.hours) do
        Comptetior::API.find_price(id)
      end
    end

Notice that in this final example, we generated a cache-key based on the model's id and update_at attributes. This is a common convention and has the benefit of invalidating the cache whenever the product is updated. In general when you use low-level caching for instance level information you need to generate a cache key.

Further reading and viewing:

* [Caching with Rails](http://guides.rubyonrails.org/caching_with_rails.html) by RailsGuides
* [Scaling Rails](http://railslab.newrelic.com/scaling-rails) by New Relic

Using from Sinatra
------------------

In your configure block:

    :::ruby
    configure do
      require 'memcached'
      CACHE = Memcached.new
    end

Test it out in a console:

    :::term
    $ irb -r myapp.rb
    >> CACHE.set('color', 'blue')

You should see output like this in your memcached -vv terminal:

    <18 set color 0 604800 7
    >18 STORED

Now read it back:

    >> CACHE.get('color')
    => "blue"

Further reading:

* [Blazing Fast Speeds with Sinatra and Memcached](http://railsillustrated.com/blazing-fast-sinatra-with-memcached.html) by Erik Andrejko


Getting Stats on Usage
----------------------

The memcached gem allows you to access your bucket's stats through the built in stats() method:

    :::term
	$ heroku console
	Ruby console for myapp.heroku.com
	>> mc = Memcached.new
	>> ... truncated output...
	>> mc.stats
	=> {:threads=>[4], :limit_maxbytes=>[67108864], :rusage_user=>[916.12], :cmd_get=>[1759086], :pointer_size=>[64], :total_connections=>[129368], :rusage_system=>[899.37], :cmd_set=>[1699375], :total_items=>[1699375], :time=>[1274128635], :evictions=>[0], :connection_structures=>[470], :version=>["1.4.4_188_g0117a2c"], :uptime=>[677746], :get_hits=>[59653], :bytes=>[2848846], :bytes_read=>[2848846], :curr_connections=>[283], :get_misses=>[1699433], :pid=>[21691], :bytes_written=>[2848846], :curr_items=>[35553]}

The limit_maxbytes is not applicable with the Northscale Memcache Add-on.  
You can not see the engine_maxbytes field which provides the actual bucket size.  Note that for bucket sizes >= 1GB, a bug may prevent you from seeing the full bucket size.
